---
description:
globs:
alwaysApply: true
---

Approach:

- Whenever doing anything that's not small, think carefully and ask any question you have to clarify.
- Be very careful with what you touch, I don't want you to remove functionality that was already there unless it's ncessary, so do a double check to make sure.

Proactively Avoiding issues

- As much as you can, you will think about where a code flow might break if the data is undefined. E.g. obj = { A: 'a' } and then we have code that checks obj.b. This will break the app. We need to do obj?.b. Ideally you use the `?` operator as much as possible to keep code clean.

Answer style

- I want answers to be very concise and to the point.
- If I start a prompt with "short" only give me the snippet. Only code. No sentences.

Naming

- never abbreviate. E.g. a param of type DataSource. should be `dataSource`, instead of `ds`. it's ok to shorten the naming but should never be cryptic. E.g. dynamicDataResolver.map(resolver => ... )

Function style

- I like files to have functions ordered by entry method at the top. Eg. the most atomic logic lives at the very bottom.
- I like to use small function that do very specific jobs.
- I don't like default exports
- I like early returns.
- I like to use functions instead of `const myFunc = () => { ... }`
- I like functions to use object params instead of inline params. Any function with more than 2 params, should use an object. E.g. myFunc(params: { param1: string, param2: boolean, param3: number})
- then I like to destructure the params on the next line.
- VERY IMPORTANT! "I always want function to be from higher level (top of file) to lower lavel/atomic (bottom of file)". E.g. if a function calls another function I'll want the called function below the caller.
- neve return the results of functions. Instead assign the fn return to a const, and then return it. that helps a lot with debugging. e.g. `const res = fn()`, then `return res`

Types:

- types that are only used in a funciton should stay above that function.

Other style

- when using if, and there's only one line in ithat if, use a single line. e.g. `if(true) doSomething()` or `if(true) return`

### Early Returns (Guideline)

- Prefer early returns to reduce nesting and improve readability.
- Handle error/empty/loading cases first, then render the success path.
- Example:

```tsx
function Example({ items }: { items?: string[] }) {
  if (!items || items.length === 0) return <Empty />
  return <List items={items} />
}
```

Folder and files

- when setting up files in folders use dash case eg. "linkedin-parser"

Comments

- Don't over comment. If it seems right to comment, only do it if the surrounding code is not clear enough. We use typescript so functions already have a lot of context. Commenting complex logic is fine. Althought it's best to apply clean code principels and modularize the complexity
- Never add comments that don't add context or clarity. E.g. when the comment essentially says the same as a function name

Error Handling

- use ts-result-custom and ts-result and result-serializable (for server to client sending of results) to handle errors
- ts-result-custom is a wrapper that automatically uses logger.error, so no need to be redundant whenver using Err(...)
- when using ts-result-custom inline the error like if(res.err) return Err(..)

Logging

- When logging/printing, always show a string to contextualize what's being logged. e.g. console.log('foo', foo) or print('foo', foo)
- When using logs I like to add an emoji. Some common ones: ‚úÖ for final logs, üåÄ when waiting for things to be loaded, üíæ When saving to db, disk, etc, ‚ùå or üóëÔ∏è when deleting, üö®for errors, üèÅ when staritng thihgs, no funny emojis, keep it very functional/descriptive.
- **Atomic Functions:** Log specific operation details, inputs, outputs, and internal success/failure.
- **Higher-Level Functions:** Log the overall process flow, context (e.g., relevant IDs), key parameters, branching decisions, and handle/log errors returned by called functions (adding context).
- **Avoid Redundancy:** Don't repeat logs already present in lower-level functions called within the chain. Focus on adding contextual value at each level.

### **Clean Code Principles**

- Code should be clear, readable, and easy to understand at a glance.
- Strive for simplicity by avoiding unnecessary complexity.
- Maintain consistency in naming, formatting, and structure across the project.
- Write modular code by breaking down logic into small, reusable functions and components.
- Keep concerns separated by organizing logic, UI, and data handling distinctly.
- Prioritize maintainability by ensuring the code is easy to modify, extend, and debug.
- Design code to scale efficiently without over-engineering upfront.
- Implement robust error handling to prevent failures and unexpected behavior.
- Use structured logging with contextual information to aid debugging and monitoring.
- Ensure code behaves predictably and remains stable under various conditions.

When asked to "apply clean code" deeply reflect on the above clean code principles and then activate planner mode (see below) to propose changes.

### UI

Never repeat the same type of ui element twice. that is, if a list of elements (e.g. nav bar) will have similar props, and same styles. Just create a component out of it. you can use [classed.ts](mdc:src/styles/classed.ts) for just styling, or a fn component at the bottom of the file that takes props.

### Testing Workflow

- **Auto-detect test files**: Before modifying any file, check if a corresponding test file exists (e.g., `src/utils/foo.ts` ‚Üí `src/utils/__tests__/foo.test.ts`)
- **Test-driven changes**: When a test file exists, follow this workflow:
  1. Run tests BEFORE making changes: `bun test path/to/test.file.ts`
  2. Make your edits to the source file
  3. Run tests AFTER changes: `bun test path/to/test.file.ts`
  4. Ensure all tests pass before considering the task complete
- **Test file headers**: Include testing workflow instructions in file headers for critical utilities
- **Test coverage**: When creating new utility functions, create comprehensive test files covering edge cases, error handling, and expected behavior

### File Organization & Imports

- **No barrel exports**: Never create `index.ts` files for re-exporting. Use direct imports from specific files instead.
- **IDE auto-import**: Rely on IDE/AI auto-import capabilities rather than manual import management through barrel files.
- **Direct file imports**: Import directly from the source file: `import { Component } from './specific-file'` not `import { Component } from './folder'`

### Vertical Spacing (Readability)

- **One blank line between logical blocks**:
  - After import groups, constant/variable declarations, permission/guard checks, loops/conditionals, I/O (FS/network/DB) calls, and before the final return.
- **Early returns**: keep a blank line after each guard return before the ‚Äúhappy path‚Äù.
- **Group related lines**: declarations together, transformations together, side-effects together; separate each group with one blank line.
- **No extra vertical noise**:
  - Never use more than one consecutive blank line.
  - No blank line immediately after `{` or immediately before `}`.
- **Small functions (<6 lines)**: blank lines are optional; prefer clarity over density.
- **Function order**: higher-level first, helpers below; keep a blank line between function definitions.

Example (preferred):

```ts
function saveFile(params: { path: string; content: string }) {
  const { path, content } = params

  if (!path) return
  if (content == null) return

  const dir = getDir(path)

  const ok = ensureWritePermission(dir)
  if (!ok) return

  const handle = openFile(dir, basename(path))

  write(handle, content)

  return
}
```
